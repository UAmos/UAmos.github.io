<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>我所知道的parallelStream | From</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">我所知道的parallelStream</h1><a id="logo" href="/.">From</a><p class="description">Amos的文章记录站</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">我所知道的parallelStream</h1><div class="post-meta">Apr 5, 2020<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.3k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 10</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>平时在工作中很喜欢写简洁的代码，Java8以后就更加容易的写出简洁的代码了。遇到Collection实现类顺手就是一个.stream或者.parallelStream。<br>stream是什么？把数据当作流水一样的处理，你可以在水流动的过程中加入你想要的操作，最终到达你要数据到达的地方。parallelStream呢？就是有多支流水，分开流淌，然后在某些节点汇合数据。<br>这边的流式处理，我认为应该是伪流式。为什么这么说，先不看整体架构，先根据数据流看看它的整个处理过程。<br>几个注意点：</p>
<ul>
<li><code>parallelStream</code>中不要用<code>InheritableThreadLocal</code>来获取主线程数据，因为内部使用线程池。</li>
<li>耗时的操作不要使用parallelStream,因为内部使用<code>ForkJoinPool.commonPool</code>,而这个是jvm内公用的，你用了别人就要等着。</li>
<li>小批量数据就不要用<code>stream</code>了,毕竟它有一堆复杂的过程，没有简单的foreach来的单纯。</li>
</ul>
<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><h3 id="Head"><a href="#Head" class="headerlink" title="Head"></a>Head</h3><p>以下代码为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lists.newArrayList(<span class="string">"1"</span>, <span class="string">"2"</span>)</span><br><span class="line">             .stream()</span><br><span class="line">             .map(s -&gt; s.concat(<span class="string">"_sub"</span>))</span><br><span class="line">             .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p><code>Collection</code>接口有一个stream()方法，主要是为了生成流对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StreamSupport.stream方法如下，返回了一个ReferencePipeline.Head，这个ReferencePipeline是主要操作类，里面有很多Ops操作，而Head是Ops操作的开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(Spliterator&lt;T&gt; spliterator, <span class="keyword">boolean</span> parallel)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(spliterator);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReferencePipeline.Head&lt;&gt;(spliterator,</span><br><span class="line">                                         StreamOpFlag.fromCharacteristics(spliterator),</span><br><span class="line">                                        parallel);</span><br></pre></td></tr></table></figure>
<p>这边还有个分离器<code>spliterator()</code>，分离器用来干什么呢？分离器是用来将你的集合值进行拆分，并行流的时候用来分成多个任务执行，这是后面执行的重要部件。数据的源头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">(Collection&lt;? extends T&gt; c,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> characteristics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IteratorSpliterator&lt;&gt;(Objects.requireNonNull(c),</span><br><span class="line">                                     characteristics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Op"><a href="#Op" class="headerlink" title="Op"></a>Op</h3><p>现在故事的开头<code>Head</code>有了，数据也有了<code>spliterator</code>,接下来就是在你要加的各种操作了。<br>以map为例，该方法返回函数处理后的流数据。整个流式数据的处理过程是个惰性求值的过程，有点像spark的处理过程，先记录需要操作的动作，等到某个触发点时候再执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    downstream.accept(mapper.apply(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边引入了<code>StatelessOp</code>,一个无状态操作类，还有一个有状态操作类<code>StatefulOp</code>,这两个操作类将会贯穿整个流式操作过程，我们的每一步中间操作都将用这两个之一进行封装。<br>这边还有一个东西<code>sink</code>-水槽，什么是<code>sink</code>呢，从代码上我们看到，一个Ops里面重写了<code>opWrapSink</code>方法,并且这个方法返回了一个<code>Sink.ChainedReference</code> 的<code>sink</code>，而此<code>sink</code>又重写了accept的方法，即真实操作方法。这边可能会有点绕，其实<code>downstream</code>就是构造函数里的<code>sink</code>，为什么叫<code>downstream</code>呢？就是说水流过了上一个水槽，变成了下游了。所以这边实际上是，一个Ops里重新包装了<code>sink</code>,而这个<code>sink</code>接受了实际的数据操作<code>mapper.apply</code>，（这个apply是Function（一个FunctionalInterface）的接口方法，传入一个值，返回另一个值），如果有多个map操作，或者说Ops，就如此再次传入执行。<br><code>AbstractPipeline.class:</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(sink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>) AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边还有个疑问，为什么是sink里是<code>downsream.accept</code>，这个<code>Consumer</code>的方法函数呢？这个函数是没有返回值的？因为水不会倒流，只会一直往下流（过段时间不知道自己是否还理解）。<br><code>sink</code>哪里来的？前面说到“spliterator”，为什么后来都是通过<code>sink</code>来操作，可以看下这段代码<br><code>AbstractPipeline.class:</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(wrappedSink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">        wrappedSink.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码将<code>spliterator</code>数据放到了操作<code>sink</code>里，sink继承了<code>Cousumer</code>，也可以看成一个操作。其实也就说明了“惰性求值”。</p>
<h3 id="TerminalOp"><a href="#TerminalOp" class="headerlink" title="TerminalOp"></a>TerminalOp</h3><p>什么时候触发真正的数据运算呢？不然定义了一堆Ops也不会执行啊！<code>Stream</code>是主要的对外的接口定义，里面定义了一堆流式计算的方法，除了上面说的<code>map</code>，还有<code>foreach</code>等。<br><code>Stream.class:</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>ReferencePipeline.class:</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> P_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">    evaluate(ForEachOps.makeRef(action, <span class="keyword">false</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;R&gt; <span class="function">R <span class="title">evaluate</span><span class="params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">getOutputShape</span><span class="params">()</span> </span>== terminalOp.inputShape();</span><br><span class="line">    <span class="keyword">if</span> (linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isParallel()</span><br><span class="line">           ? terminalOp.evaluateParallel(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()))</span><br><span class="line">           : terminalOp.evaluateSequential(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当遇到终端Op时，流式也就到头了，前面的铺垫都要开始执行了。根据是否并行计算<code>isParallel</code>，分为两条执行路线，先看非并行的<code>evaluateSequential</code>。以<code>ForEachOp</code>为例<br><code>ForEachOps.class:</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;S&gt; <span class="function">Void <span class="title">evaluateSequential</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Spliterator&lt;S&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper.wrapAndCopyInto(<span class="keyword">this</span>, spliterator).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AbstractPipeline.class:</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;P_IN, S extends Sink&lt;E_OUT&gt;&gt; <span class="function">S <span class="title">wrapAndCopyInto</span><span class="params">(S sink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);</span><br><span class="line">    <span class="keyword">return</span> sink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(wrappedSink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">        wrappedSink.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>copyInto</code>前面说过了，就是将数据源spliterator转入sink操作，wrapSink前面也说过了，就是将各种中间Ops封装，变成一条链。所以这整个一条stream就走完了，看似复杂，也没想像的那么难理解。</p>
<h2 id="parallelStream"><a href="#parallelStream" class="headerlink" title="parallelStream"></a>parallelStream</h2><p>接下来我们来看下前面的另一条分支：<code>terminalOp.evaluateParallel</code>，还是以<code>ForEachOps</code>的代码为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;S&gt; <span class="function">Void <span class="title">evaluateParallel</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Spliterator&lt;S&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ordered)</span><br><span class="line">        <span class="keyword">new</span> ForEachOrderedTask&lt;&gt;(helper, spliterator, <span class="keyword">this</span>).invoke();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ForEachTask&lt;&gt;(helper, spliterator, helper.wrapSink(<span class="keyword">this</span>)).invoke();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它根据是否要按顺序输出计算结果，分成了两个分支，对应了两个Task的任务。这个Task是什么，这就要了解下什么是<code>ForkJoin</code>.先说结果，<code>parallelStream</code>内部使用了一个线程池<code>ForkJoinPool.commonPool</code>，加上前面说的分离器<code>Spliterator</code>，分离器将任务有效的切分成多个任务，通过线程池里的线程并发的执行，当然主任务也是有参与执行的，加上<code>ForkJoin</code>的特点，再将任务进行<code>join</code>合并。由此实现了多线程的并发执行。</p>
<h3 id="ForkJoin框架"><a href="#ForkJoin框架" class="headerlink" title="ForkJoin框架"></a>ForkJoin框架</h3><p>谈到parallelStream就不得不看的线程池ForkJoinPool，不得不谈到ForkJoinTask。<br>用个例子说明<code>ForkJoinTask</code>的使用，实现了它的一个子类。</p>
<ul>
<li><code>RecursiveTask</code> 有返回值的抽象类</li>
<li><code>RecursiveAction</code> 没有返回值的抽象类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocalTest</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start="</span> + start + <span class="string">",end="</span> + end);</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end - start &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            ThreadLocalTest r = <span class="keyword">new</span> ThreadLocalTest(start, start + <span class="number">9</span>);</span><br><span class="line">            r.fork();</span><br><span class="line">            sum += r.join();</span><br><span class="line">            start = start + <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程id="</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程id="</span> + Thread.currentThread().getId());</span><br><span class="line">        ThreadLocalTest tlt = <span class="keyword">new</span> ThreadLocalTest(<span class="number">1</span>, <span class="number">202</span>);</span><br><span class="line">        System.out.println(tlt.invoke());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子是用来计算公差为1的等差数列之和，我使用ForkJoin，将10个数作为一个子计算，然后将这些子集散汇总得到最后的值。输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">线程id=<span class="number">1</span></span><br><span class="line">线程id=<span class="number">13</span></span><br><span class="line">start=<span class="number">1</span>,end=<span class="number">10</span></span><br><span class="line">线程id=<span class="number">13</span></span><br><span class="line">start=<span class="number">11</span>,end=<span class="number">20</span></span><br><span class="line">线程id=<span class="number">13</span></span><br><span class="line">start=<span class="number">21</span>,end=<span class="number">30</span></span><br><span class="line">线程id=<span class="number">13</span></span><br><span class="line">start=<span class="number">31</span>,end=<span class="number">40</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">41</span>,end=<span class="number">50</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">51</span>,end=<span class="number">60</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">61</span>,end=<span class="number">70</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">71</span>,end=<span class="number">80</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">81</span>,end=<span class="number">90</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">91</span>,end=<span class="number">100</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">101</span>,end=<span class="number">110</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">111</span>,end=<span class="number">120</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">121</span>,end=<span class="number">130</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">131</span>,end=<span class="number">140</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">141</span>,end=<span class="number">150</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">151</span>,end=<span class="number">160</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">161</span>,end=<span class="number">170</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">171</span>,end=<span class="number">180</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">181</span>,end=<span class="number">190</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">191</span>,end=<span class="number">200</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">201</span>,end=<span class="number">202</span></span><br><span class="line"><span class="number">20503</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，主线程也参与了计算，少了一次线程池的计算。这中思想跟spark，MP的分而治之一样。</p>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>回到刚才的<code>ForEachTask</code>，使用的就是<code>ForkJoin</code>框架，我们看下它的实现方法，也是主线程加入计算的。<br><code>ForEachOps.ForEachTask.class:</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Spliterator&lt;S&gt; rightSplit = spliterator, leftSplit;</span><br><span class="line">            <span class="keyword">long</span> sizeEstimate = rightSplit.estimateSize(), sizeThreshold;</span><br><span class="line">            <span class="keyword">if</span> ((sizeThreshold = targetSize) == <span class="number">0L</span>)</span><br><span class="line">                targetSize = sizeThreshold = AbstractTask.suggestTargetSize(sizeEstimate);</span><br><span class="line">            <span class="keyword">boolean</span> isShortCircuit = StreamOpFlag.SHORT_CIRCUIT.isKnown(helper.getStreamAndOpFlags());</span><br><span class="line">            <span class="keyword">boolean</span> forkRight = <span class="keyword">false</span>;</span><br><span class="line">            Sink&lt;S&gt; taskSink = sink;</span><br><span class="line">            ForEachTask&lt;S, T&gt; task = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isShortCircuit || !taskSink.cancellationRequested()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sizeEstimate &lt;= sizeThreshold ||</span><br><span class="line">                    (leftSplit = rightSplit.trySplit()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    task.helper.copyInto(taskSink, rightSplit);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ForEachTask&lt;S, T&gt; leftTask = <span class="keyword">new</span> ForEachTask&lt;&gt;(task, leftSplit);</span><br><span class="line">                task.addToPendingCount(<span class="number">1</span>);</span><br><span class="line">                ForEachTask&lt;S, T&gt; taskToFork;</span><br><span class="line">                <span class="keyword">if</span> (forkRight) &#123;</span><br><span class="line">                    forkRight = <span class="keyword">false</span>;</span><br><span class="line">                    rightSplit = leftSplit;</span><br><span class="line">                    taskToFork = task;</span><br><span class="line">                    task = leftTask;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    forkRight = <span class="keyword">true</span>;</span><br><span class="line">                    taskToFork = leftTask;</span><br><span class="line">                &#125;</span><br><span class="line">                taskToFork.fork();</span><br><span class="line">                sizeEstimate = rightSplit.estimateSize();</span><br><span class="line">            &#125;</span><br><span class="line">            task.spliterator = <span class="keyword">null</span>;</span><br><span class="line">            task.propagateCompletion();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/%E6%BA%90%E7%A0%81/">源码</a></div><div class="post-nav"><a class="next" href="/2020/03/31/Maven%E4%B9%8B%E5%8F%91%E5%B8%83%E5%8C%85-%E7%A7%81%E6%9C%8D/">Maven之发布包-私服</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E8%A3%85/">安装</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%B9%E5%99%A8/">容器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BB%BA%E7%AB%99/">建站</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 15px;">源码</a> <a href="/tags/%E9%9D%9E%E5%8E%9F%E5%88%9B/" style="font-size: 15px;">非原创</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/SonarQube/" style="font-size: 15px;">SonarQube</a> <a href="/tags/%E5%8E%9F%E7%90%86/" style="font-size: 15px;">原理</a> <a href="/tags/%E9%87%8D%E6%9E%84/" style="font-size: 15px;">重构</a> <a href="/tags/%E7%BB%8F%E9%AA%8C/" style="font-size: 15px;">经验</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/" style="font-size: 15px;">代码片段</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/05/%E6%88%91%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84parallelStream/">我所知道的parallelStream</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/Maven%E4%B9%8B%E5%8F%91%E5%B8%83%E5%8C%85-%E7%A7%81%E6%9C%8D/">Maven之发布包-私服</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/Maven%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Maven之生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/Maven%E4%B9%8B%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/">Maven之插件开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/05/System-getProperty%E6%89%80%E6%8B%A5%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7/">System.getProperty所拥有的属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/05/Java8-%E6%A0%B9%E6%8D%AE%E5%B1%9E%E6%80%A7%E5%80%BC%E5%8E%BB%E9%87%8D/">Java8 根据属性值去重</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/05/Docker%E5%90%AF%E5%8A%A8Hadoop%E6%8A%A5%E9%94%99/">Docker启动Hadoop报错</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/03/Linux%E4%B8%8BSonarQube%E6%90%AD%E5%BB%BA/">Linux下SonarQube搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/02/Java%E4%B9%8BBitSet/">Java之BitSet</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.baidu.com/" title="百度一下，你就知道" target="_blank">百度一下，你就知道</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">From.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
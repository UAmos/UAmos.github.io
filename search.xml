<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我所知道的parallelStream</title>
      <link href="/2020/04/05/%E6%88%91%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84parallelStream/"/>
      <url>/2020/04/05/%E6%88%91%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84parallelStream/</url>
      
        <content type="html"><![CDATA[<h1 id="Java流式计算"><a href="#Java流式计算" class="headerlink" title="Java流式计算"></a>Java流式计算</h1><p>平时在工作中很喜欢写简洁的代码，Java8以后就更加容易的写出简洁的代码了。遇到Collection实现类顺手就是一个.stream或者.parallelStream。<br>stream是什么？把数据当作流水一样的处理，你可以在水流动的过程中加入你想要的操作，最终到达你要数据到达的地方。parallelStream呢？就是有多支流水，分开流淌，然后在某些节点汇合数据。<br>这边的流式处理，我认为应该是伪流式。为什么这么说，先不看整体架构，先根据数据流看看它的整个处理过程。<br>几个注意点：</p><ul><li><code>parallelStream</code>中不要用<code>InheritableThreadLocal</code>来获取主线程数据，因为内部使用线程池。</li><li>耗时的操作不要使用parallelStream,因为内部使用<code>ForkJoinPool.commonPool</code>,而这个是jvm内公用的，你用了别人就要等着。</li><li>小批量数据就不要用<code>stream</code>了,毕竟它有一堆复杂的过程，没有简单的foreach来的单纯。</li></ul><h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><h3 id="Head"><a href="#Head" class="headerlink" title="Head"></a>Head</h3><p>以下代码为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lists.newArrayList(<span class="string">"1"</span>, <span class="string">"2"</span>)</span><br><span class="line">             .stream()</span><br><span class="line">             .map(s -&gt; s.concat(<span class="string">"_sub"</span>))</span><br><span class="line">             .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><code>Collection</code>接口有一个stream()方法，主要是为了生成流对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StreamSupport.stream方法如下，返回了一个ReferencePipeline.Head，这个ReferencePipeline是主要操作类，里面有很多Ops操作，而Head是Ops操作的开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(Spliterator&lt;T&gt; spliterator, <span class="keyword">boolean</span> parallel)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(spliterator);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReferencePipeline.Head&lt;&gt;(spliterator,</span><br><span class="line">                                         StreamOpFlag.fromCharacteristics(spliterator),</span><br><span class="line">                                        parallel);</span><br></pre></td></tr></table></figure><p>这边还有个分离器<code>spliterator()</code>，分离器用来干什么呢？分离器是用来将你的集合值进行拆分，并行流的时候用来分成多个任务执行，这是后面执行的重要部件。数据的源头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">(Collection&lt;? extends T&gt; c,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> characteristics)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IteratorSpliterator&lt;&gt;(Objects.requireNonNull(c),</span><br><span class="line">                                     characteristics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Op"><a href="#Op" class="headerlink" title="Op"></a>Op</h3><p>现在故事的开头<code>Head</code>有了，数据也有了<code>spliterator</code>,接下来就是在你要加的各种操作了。<br>以map为例，该方法返回函数处理后的流数据。整个流式数据的处理过程是个惰性求值的过程，有点像spark的处理过程，先记录需要操作的动作，等到某个触发点时候再执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    downstream.accept(mapper.apply(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边引入了<code>StatelessOp</code>,一个无状态操作类，还有一个有状态操作类<code>StatefulOp</code>,这两个操作类将会贯穿整个流式操作过程，我们的每一步中间操作都将用这两个之一进行封装。<br>这边还有一个东西<code>sink</code>-水槽，什么是<code>sink</code>呢，从代码上我们看到，一个Ops里面重写了<code>opWrapSink</code>方法,并且这个方法返回了一个<code>Sink.ChainedReference</code> 的<code>sink</code>，而此<code>sink</code>又重写了accept的方法，即真实操作方法。这边可能会有点绕，其实<code>downstream</code>就是构造函数里的<code>sink</code>，为什么叫<code>downstream</code>呢？就是说水流过了上一个水槽，变成了下游了。所以这边实际上是，一个Ops里重新包装了<code>sink</code>,而这个<code>sink</code>接受了实际的数据操作<code>mapper.apply</code>，（这个apply是Function（一个FunctionalInterface）的接口方法，传入一个值，返回另一个值），如果有多个map操作，或者说Ops，就如此再次传入执行。<br><code>AbstractPipeline.class:</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(sink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>) AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边还有个疑问，为什么是sink里是<code>downsream.accept</code>，这个<code>Consumer</code>的方法函数呢？这个函数是没有返回值的？因为水不会倒流，只会一直往下流（过段时间不知道自己是否还理解）。<br><code>sink</code>哪里来的？前面说到“spliterator”，为什么后来都是通过<code>sink</code>来操作，可以看下这段代码<br><code>AbstractPipeline.class:</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(wrappedSink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">        wrappedSink.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将<code>spliterator</code>数据放到了操作<code>sink</code>里，sink继承了<code>Cousumer</code>，也可以看成一个操作。其实也就说明了“惰性求值”。</p><h3 id="TerminalOp"><a href="#TerminalOp" class="headerlink" title="TerminalOp"></a>TerminalOp</h3><p>什么时候触发真正的数据运算呢？不然定义了一堆Ops也不会执行啊！<code>Stream</code>是主要的对外的接口定义，里面定义了一堆流式计算的方法，除了上面说的<code>map</code>，还有<code>foreach</code>等。<br><code>Stream.class:</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure><p><code>ReferencePipeline.class:</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> P_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">    evaluate(ForEachOps.makeRef(action, <span class="keyword">false</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;R&gt; <span class="function">R <span class="title">evaluate</span><span class="params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">getOutputShape</span><span class="params">()</span> </span>== terminalOp.inputShape();</span><br><span class="line">    <span class="keyword">if</span> (linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isParallel()</span><br><span class="line">           ? terminalOp.evaluateParallel(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()))</span><br><span class="line">           : terminalOp.evaluateSequential(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当遇到终端Op时，流式也就到头了，前面的铺垫都要开始执行了。根据是否并行计算<code>isParallel</code>，分为两条执行路线，先看非并行的<code>evaluateSequential</code>。以<code>ForEachOp</code>为例<br><code>ForEachOps.class:</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;S&gt; <span class="function">Void <span class="title">evaluateSequential</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Spliterator&lt;S&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper.wrapAndCopyInto(<span class="keyword">this</span>, spliterator).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractPipeline.class:</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;P_IN, S extends Sink&lt;E_OUT&gt;&gt; <span class="function">S <span class="title">wrapAndCopyInto</span><span class="params">(S sink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);</span><br><span class="line">    <span class="keyword">return</span> sink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(wrappedSink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">        wrappedSink.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>copyInto</code>前面说过了，就是将数据源spliterator转入sink操作，wrapSink前面也说过了，就是将各种中间Ops封装，变成一条链。所以这整个一条stream就走完了，看似复杂，也没想像的那么难理解。</p><h2 id="parallelStream"><a href="#parallelStream" class="headerlink" title="parallelStream"></a>parallelStream</h2><p>接下来我们来看下前面的另一条分支：<code>terminalOp.evaluateParallel</code>，还是以<code>ForEachOps</code>的代码为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;S&gt; <span class="function">Void <span class="title">evaluateParallel</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Spliterator&lt;S&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ordered)</span><br><span class="line">        <span class="keyword">new</span> ForEachOrderedTask&lt;&gt;(helper, spliterator, <span class="keyword">this</span>).invoke();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ForEachTask&lt;&gt;(helper, spliterator, helper.wrapSink(<span class="keyword">this</span>)).invoke();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它根据是否要按顺序输出计算结果，分成了两个分支，对应了两个Task的任务。这个Task是什么，这就要了解下什么是<code>ForkJoin</code>.先说结果，<code>parallelStream</code>内部使用了一个线程池<code>ForkJoinPool.commonPool</code>，加上前面说的分离器<code>Spliterator</code>，分离器将任务有效的切分成多个任务，通过线程池里的线程并发的执行，当然主任务也是有参与执行的，加上<code>ForkJoin</code>的特点，再将任务进行<code>join</code>合并。由此实现了多线程的并发执行。</p><h3 id="ForkJoin框架"><a href="#ForkJoin框架" class="headerlink" title="ForkJoin框架"></a>ForkJoin框架</h3><p>谈到parallelStream就不得不看的线程池ForkJoinPool，不得不谈到ForkJoinTask。<br>用个例子说明<code>ForkJoinTask</code>的使用，实现了它的一个子类。</p><ul><li><code>RecursiveTask</code> 有返回值的抽象类</li><li><code>RecursiveAction</code> 没有返回值的抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocalTest</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start="</span> + start + <span class="string">",end="</span> + end);</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (end - start &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            ThreadLocalTest r = <span class="keyword">new</span> ThreadLocalTest(start, start + <span class="number">9</span>);</span><br><span class="line">            r.fork();</span><br><span class="line">            sum += r.join();</span><br><span class="line">            start = start + <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程id="</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程id="</span> + Thread.currentThread().getId());</span><br><span class="line">        ThreadLocalTest tlt = <span class="keyword">new</span> ThreadLocalTest(<span class="number">1</span>, <span class="number">202</span>);</span><br><span class="line">        System.out.println(tlt.invoke());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子是用来计算公差为1的等差数列之和，我使用ForkJoin，将10个数作为一个子计算，然后将这些子集散汇总得到最后的值。输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">线程id=<span class="number">1</span></span><br><span class="line">线程id=<span class="number">13</span></span><br><span class="line">start=<span class="number">1</span>,end=<span class="number">10</span></span><br><span class="line">线程id=<span class="number">13</span></span><br><span class="line">start=<span class="number">11</span>,end=<span class="number">20</span></span><br><span class="line">线程id=<span class="number">13</span></span><br><span class="line">start=<span class="number">21</span>,end=<span class="number">30</span></span><br><span class="line">线程id=<span class="number">13</span></span><br><span class="line">start=<span class="number">31</span>,end=<span class="number">40</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">41</span>,end=<span class="number">50</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">51</span>,end=<span class="number">60</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">61</span>,end=<span class="number">70</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">71</span>,end=<span class="number">80</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">81</span>,end=<span class="number">90</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">91</span>,end=<span class="number">100</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">101</span>,end=<span class="number">110</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">111</span>,end=<span class="number">120</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">121</span>,end=<span class="number">130</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">131</span>,end=<span class="number">140</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">141</span>,end=<span class="number">150</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">151</span>,end=<span class="number">160</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">161</span>,end=<span class="number">170</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">171</span>,end=<span class="number">180</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">181</span>,end=<span class="number">190</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">191</span>,end=<span class="number">200</span></span><br><span class="line">线程id=<span class="number">1</span></span><br><span class="line">start=<span class="number">201</span>,end=<span class="number">202</span></span><br><span class="line"><span class="number">20503</span></span><br></pre></td></tr></table></figure><p>在这个例子中，主线程也参与了计算，少了一次线程池的计算。这中思想跟spark，MP的分而治之一样。</p><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>回到刚才的<code>ForEachTask</code>，使用的就是<code>ForkJoin</code>框架，我们看下它的实现方法，也是主线程加入计算的。<br><code>ForEachOps.ForEachTask.class:</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Spliterator&lt;S&gt; rightSplit = spliterator, leftSplit;</span><br><span class="line">            <span class="keyword">long</span> sizeEstimate = rightSplit.estimateSize(), sizeThreshold;</span><br><span class="line">            <span class="keyword">if</span> ((sizeThreshold = targetSize) == <span class="number">0L</span>)</span><br><span class="line">                targetSize = sizeThreshold = AbstractTask.suggestTargetSize(sizeEstimate);</span><br><span class="line">            <span class="keyword">boolean</span> isShortCircuit = StreamOpFlag.SHORT_CIRCUIT.isKnown(helper.getStreamAndOpFlags());</span><br><span class="line">            <span class="keyword">boolean</span> forkRight = <span class="keyword">false</span>;</span><br><span class="line">            Sink&lt;S&gt; taskSink = sink;</span><br><span class="line">            ForEachTask&lt;S, T&gt; task = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isShortCircuit || !taskSink.cancellationRequested()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sizeEstimate &lt;= sizeThreshold ||</span><br><span class="line">                    (leftSplit = rightSplit.trySplit()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    task.helper.copyInto(taskSink, rightSplit);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ForEachTask&lt;S, T&gt; leftTask = <span class="keyword">new</span> ForEachTask&lt;&gt;(task, leftSplit);</span><br><span class="line">                task.addToPendingCount(<span class="number">1</span>);</span><br><span class="line">                ForEachTask&lt;S, T&gt; taskToFork;</span><br><span class="line">                <span class="keyword">if</span> (forkRight) &#123;</span><br><span class="line">                    forkRight = <span class="keyword">false</span>;</span><br><span class="line">                    rightSplit = leftSplit;</span><br><span class="line">                    taskToFork = task;</span><br><span class="line">                    task = leftTask;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    forkRight = <span class="keyword">true</span>;</span><br><span class="line">                    taskToFork = leftTask;</span><br><span class="line">                &#125;</span><br><span class="line">                taskToFork.fork();</span><br><span class="line">                sizeEstimate = rightSplit.estimateSize();</span><br><span class="line">            &#125;</span><br><span class="line">            task.spliterator = <span class="keyword">null</span>;</span><br><span class="line">            task.propagateCompletion();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven之发布包-私服</title>
      <link href="/2020/03/31/Maven%E4%B9%8B%E5%8F%91%E5%B8%83%E5%8C%85-%E7%A7%81%E6%9C%8D/"/>
      <url>/2020/03/31/Maven%E4%B9%8B%E5%8F%91%E5%B8%83%E5%8C%85-%E7%A7%81%E6%9C%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="Maven上传jar到私服"><a href="#Maven上传jar到私服" class="headerlink" title="Maven上传jar到私服"></a>Maven上传jar到私服</h3><h4 id="修改maven-settings配置文件"><a href="#修改maven-settings配置文件" class="headerlink" title="修改maven settings配置文件"></a>修改maven settings配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>userName<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>userName<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修改pom配置文件"><a href="#修改pom配置文件" class="headerlink" title="修改pom配置文件"></a>修改pom配置文件</h4><p>这边配置了release和snapshot</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- id要和setting的id一致 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://ip:port/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://ip:port/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="父子模块-部署单子模块"><a href="#父子模块-部署单子模块" class="headerlink" title="父子模块 部署单子模块"></a>父子模块 部署单子模块</h4><p>项目是父子模块，但是只有api模块需要上传私服供他人使用，可以在不需要deploy的子模块中的pom加入以下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven之生命周期</title>
      <link href="/2020/03/31/Maven%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/03/31/Maven%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven之插件开发</title>
      <link href="/2020/03/31/Maven%E4%B9%8B%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/2020/03/31/Maven%E4%B9%8B%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2020/03/29/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/03/29/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="一-内存模型的相关概念"><a href="#一-内存模型的相关概念" class="headerlink" title="一.内存模型的相关概念"></a>一.内存模型的相关概念</h4><p>　　大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就<br>存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p><p>　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p> 　　当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。<br>　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。<br>　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？<br>　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。<br>　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。<br>　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。<br>　　为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p><ul><li>1）通过在总线加LOCK#锁的方式</li><li>2）通过缓存一致性协议</li></ul><p>这2种方式都是硬件层面上提供的方式。<br>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。<br>　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。<br>　　所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><h4 id="二-并发编程中的三个概念"><a href="#二-并发编程中的三个概念" class="headerlink" title="二.并发编程中的三个概念"></a>二.并发编程中的三个概念</h4><p>　　在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p><h6 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h6><p>　　原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>　　一个很经典的例子就是银行账户转账问题：<br>　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。<br>　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。<br>　　所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。<br>　　同样地反映到并发编程中会出现什么结果呢？<br>　　举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">9</span>;</span><br></pre></td></tr></table></figure><p> 　　假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p><p>　　那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p><h6 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h6><p>　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>　　举个简单的例子，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p><p>　　此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.<br>　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><h6 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h6><p>　　有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1</span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure><p> 　　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p><p>　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。<br>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。<br>　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2</span></span><br><span class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></span><br><span class="line">r = a*a;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure><p> 　　这段代码有4个语句，那么可能的一个执行顺序是：<br><code>2 -&gt; 1 -&gt; 3 -&gt;4</code><br>　　那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3<br>　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。<br>　　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p> 　　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。<br> 　　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。<br>　　也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p><h4 id="三-Java内存模型"><a href="#三-Java内存模型" class="headerlink" title="三.Java内存模型"></a>三.Java内存模型</h4><p>　　在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。<br>　　在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。<br>　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。<br>　　举个简单的例子：在java中，执行下面这个语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i  = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p> 　　执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。<br>　　那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p><h6 id="1-原子性-1"><a href="#1-原子性-1" class="headerlink" title="1.原子性"></a>1.原子性</h6><p>　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。<br>　　上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：<br>　　请分析以下哪些操作是原子性操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;         <span class="comment">//语句1</span></span><br><span class="line">y = x;         <span class="comment">//语句2</span></span><br><span class="line">x++;           <span class="comment">//语句3</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure><p>   咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。<br>   语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。<br>   语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。<br>   同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。<br>   所以上面4个语句只有语句1的操作具备原子性。<br>　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。<br>　　不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。<br>　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p><h6 id="2-可见性-1"><a href="#2-可见性-1" class="headerlink" title="2.可见性"></a>2.可见性</h6><p>　　对于可见性，Java提供了volatile关键字来保证可见性。<br>　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>　　而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><h6 id="3-有序性-1"><a href="#3-有序性-1" class="headerlink" title="3.有序性"></a>3.有序性</h6><p>　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br>　　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。<br>　　另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br>　　下面就来具体介绍下happens-before原则（先行发生原则）：<br>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作<br>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作<br>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作<br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br>　　这8条原则摘自《深入理解Java虚拟机》。<br>　　这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。<br>　　下面我们来解释一下前4条规则：<br>　　对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。<br>　　第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。<br>　　第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。<br>　　第四条规则实际上就是体现happens-before原则具备传递性。</p><h4 id="四-深入剖析volatile关键字"><a href="#四-深入剖析volatile关键字" class="headerlink" title="四.深入剖析volatile关键字"></a>四.深入剖析volatile关键字</h4><p>　　在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p><ol><li>volatile关键字的两层语义<br>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>　　1) 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>　　2) 禁止进行指令重排序。<br>　　先看一段代码，假如线程1先执行，线程2后执行：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>　　这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。<br>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。<br>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。<br>　　但是用volatile修饰之后就变得不一样了：<br>　　第一：使用volatile关键字会强制将修改的值立即写入主存；<br>　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；<br>　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。<br>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。<br>那么线程1读取到的就是最新的正确的值。</li><li>volatile保证原子性吗？<br>　　从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？<br>　　下面看一个例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>　　大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。<br>　　可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。<br>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。<br>　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：<br>　　假如某个时刻变量inc的值为10，<br>　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；<br>　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。<br>　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。<br>　　那么两个线程分别进行了一次自增操作后，inc只增加了1。<br>　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。<br>　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。<br>　　把上面的代码改成以下任何一种都可以达到效果：<br>　　采用synchronized：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>　　采用Lock：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inc++;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>　　采用AtomicInteger：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  AtomicInteger inc = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>　　在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</li></ol><p>3.volatile能保证有序性吗？</p><p>　　在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p><p>　　volatile关键字禁止指令重排序有两层意思：</p><p>　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p><p>　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p><p>　　可能上面说的比较绕，举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x、y为非volatile变量</span></span><br><span class="line"><span class="comment">//flag为volatile变量</span></span><br><span class="line"> </span><br><span class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></span><br><span class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></span><br><span class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3</span></span><br><span class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></span><br><span class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></span><br></pre></td></tr></table></figure><p> 　　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p><p>　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p><p>　　那么我们回到前面举的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p> 　　前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p><p>　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p><p>4.volatile的原理和实现机制</p><p>　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p><p>　　下面这段话摘自《深入理解Java虚拟机》：</p><p>　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p><p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p>　　2）它会强制将对缓存的修改操作立即写入主存；</p><p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><h4 id="五-使用volatile关键字的场景"><a href="#五-使用volatile关键字的场景" class="headerlink" title="五.使用volatile关键字的场景"></a>五.使用volatile关键字的场景</h4><p>　　synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p><p>　　1）对变量的写操作不依赖于当前值</p><p>　　2）该变量没有包含在具有其他变量的不变式中</p><p>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p><p>　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p><p>　　下面列举几个Java中使用volatile的几个场景。</p><ol><li>状态标记量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = <span class="keyword">true</span>;            </span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></li><li>double check<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>转载自：&lt;<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 非原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System.getProperty所拥有的属性</title>
      <link href="/2020/01/05/System-getProperty%E6%89%80%E6%8B%A5%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
      <url>/2020/01/05/System-getProperty%E6%89%80%E6%8B%A5%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">java.version Java 运行时环境版本</span><br><span class="line">java.vendor Java 运行时环境供应商</span><br><span class="line">java.vendor.url Java 供应商的 URL</span><br><span class="line">java.home Java 安装目录</span><br><span class="line">java.vm.specification.version Java 虚拟机规范版本</span><br><span class="line">java.vm.specification.vendor Java 虚拟机规范供应商</span><br><span class="line">java.vm.specification.name Java 虚拟机规范名称</span><br><span class="line">java.vm.version Java 虚拟机实现版本</span><br><span class="line">java.vm.vendor Java 虚拟机实现供应商</span><br><span class="line">java.vm.name Java 虚拟机实现名称</span><br><span class="line">java.specification.version Java 运行时环境规范版本</span><br><span class="line">java.specification.vendor Java 运行时环境规范供应商</span><br><span class="line">java.specification.name Java 运行时环境规范名称</span><br><span class="line">java.class.version Java 类格式版本号</span><br><span class="line">java.class.path Java 类路径</span><br><span class="line">java.library.path 加载库时搜索的路径列表</span><br><span class="line">java.io.tmpdir 默认的临时文件路径</span><br><span class="line">java.compiler 要使用的 JIT 编译器的名称</span><br><span class="line">java.ext.dirs 一个或多个扩展目录的路径</span><br><span class="line">os.name 操作系统的名称</span><br><span class="line">os.arch 操作系统的架构</span><br><span class="line">os.version 操作系统的版本</span><br><span class="line">file.separator 文件分隔符（在 UNIX 系统中是“&#x2F;”）</span><br><span class="line">path.separator 路径分隔符（在 UNIX 系统中是“:”）</span><br><span class="line">line.separator 行分隔符（在 UNIX 系统中是“&#x2F;n”）</span><br><span class="line">user.name 用户的账户名称</span><br><span class="line">user.home 用户的主目录</span><br><span class="line">user.dir 用户的当前工作目录</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java8 根据属性值去重</title>
      <link href="/2020/01/05/Java8-%E6%A0%B9%E6%8D%AE%E5%B1%9E%E6%80%A7%E5%80%BC%E5%8E%BB%E9%87%8D/"/>
      <url>/2020/01/05/Java8-%E6%A0%B9%E6%8D%AE%E5%B1%9E%E6%80%A7%E5%80%BC%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Object&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        Map&lt;Object, Boolean&gt; seen = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> object -&gt; seen.putIfAbsent(keyExtractor.apply(object), Boolean.TRUE) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码片段 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker启动Hadoop报错</title>
      <link href="/2020/01/05/Docker%E5%90%AF%E5%8A%A8Hadoop%E6%8A%A5%E9%94%99/"/>
      <url>/2020/01/05/Docker%E5%90%AF%E5%8A%A8Hadoop%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>使用docker启动hadoop时，报以下错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[xhw@192 ~]$ docker run -p9000:9000 -it sequenceiq/hadoop-docker:latest -bash</span><br><span class="line">WARNING: IPv4 forwarding is disabled. Networking will not work.</span><br><span class="line">docker: Error response from daemon: driver failed programming external connectivity on endpoint hungry_neumann (b5668ce9501b598dbe879cac6353831964cc073997305f7d16376a3abb840de7):  (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 9000 -j DNAT --to-destination 172.17.0.2:9000 ! -i docker0: iptables: No chain/target/match by that name.</span><br><span class="line"> (exit status 1)).</span><br></pre></td></tr></table></figure><p>原因：<code>docker</code> 服务启动的时候，<code>docker</code>服务会向<code>iptables</code>注册一个链，以便让<code>docker</code>服务管理的<code>containner</code>所暴露的端口之间进行通信，通过命令<code>iptables -L</code>可以查看<code>iptables</code> 链<br>报这个错应该是iptables被改变或者什么的，所以只要重启docker服务，重新加载iptable链即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xhw@192 ~]$ service docker restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 容器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下SonarQube搭建</title>
      <link href="/2020/01/03/Linux%E4%B8%8BSonarQube%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/01/03/Linux%E4%B8%8BSonarQube%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>SonarQube支持多种语言的检测，内部使用了ElasticSearch用于搜索。<br><font color=red>注意：ElasticSearch不能使用root用户启动，所以需要使用其他用户。</font><br>以下在Centos下搭建SonarQube步骤</p><ol><li>安装JDK1.8，高级版本的SonarQube使用的JDK1.8，安装Centos是会可以选择自动安装。</li><li>可以新建一个目录存放下载的SonarQube压缩文件，这边下载的是7.2.1版本。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xhw@192 ~]$ wget https://sonarsource.bintray.com/Distribution/sonarqube/sonarqube-7.2.1.zip</span><br></pre></td></tr></table></figure><ol start="3"><li><p>解压下载的zip文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[xhw@192 ~]$ unzip sonarqube-7.2.1.zip</span><br></pre></td></tr></table></figure></li><li><p>安装中文插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[xhw@192 ~]$ cd sonarqube-7.2.1/extensions/plugins</span><br><span class="line">[xhw@192 plugins]$ wget https://github.com/SonarQubeCommunity/sonar-l10n-zh/releases/download/sonar-l10n-zh-plugin-1.22/sonar-l10n-zh-plugin-1.22.jar</span><br></pre></td></tr></table></figure></li><li><p>使用mysql数据存储数据，先建sonar数据库，然后修改<code>sonar.properties</code>。mysql版本应大于5.5小于8<br><em>（编辑时意外退出会出现swap文件，使用：ll -a 显示然后删除即可）<br>mysql用户如果要支持远程登录的，需要将用户表的host改为%，并刷新。</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> mysql.user;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[xhw@192 ~]$ cd sonarqube-7.2.1/conf/</span><br><span class="line">[xhw@192 conf]$ vim sonar.properties </span><br><span class="line">sonar.jdbc.username=root</span><br><span class="line">sonar.jdbc.password=root</span><br><span class="line">sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false</span><br></pre></td></tr></table></figure></li><li><p>启动sonar（有时候第二次以上启动会启动失败，应删除tmp和logs文件夹就可以了）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[xhw@192 ~]$ cd sonarqube-7.2.1/bin/linux-x86-64/</span><br><span class="line">[xhw@192 linux-x86-64]$ ./sonar.sh start</span><br><span class="line">[xhw@192 linux-x86-64]$ ./sonar.sh stop  ##停止服务</span><br></pre></td></tr></table></figure></li></ol><h4 id="MySql：下载安装"><a href="#MySql：下载安装" class="headerlink" title="MySql：下载安装"></a>MySql：下载安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;dev.mysql.com&#x2F;downloads&#x2F;installer&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;cdn.mysql.com&#x2F;&#x2F;Downloads&#x2F;MySQLInstaller&#x2F;mysql-installer-community-5.7.22.1.msi</span><br></pre></td></tr></table></figure><h3 id="基于maven进行代码检查"><a href="#基于maven进行代码检查" class="headerlink" title="基于maven进行代码检查"></a>基于maven进行代码检查</h3><ol><li>maven的setting.xml文件加入profile<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.sonarsource.scanner.maven<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>sonar<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置 Sonar Host地址，默认：http://localhost:9000 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sonar.host.url</span>&gt;</span></span><br><span class="line">                  http://localhost:9000</span><br><span class="line">                <span class="tag">&lt;/<span class="name">sonar.host.url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>pom.xml文件加入插件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonarsource.scanner.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sonar-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0.603<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SonarQube </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java之BitSet</title>
      <link href="/2020/01/02/Java%E4%B9%8BBitSet/"/>
      <url>/2020/01/02/Java%E4%B9%8BBitSet/</url>
      
        <content type="html"><![CDATA[<p>BitSet通过位运算进行数据的标示，内部使用long数组进行存储，即64位bit。<br>有两个方法需要注意：</p><ol><li>size()：表示BitSet实际使用的空间数，如10100，占用空间数为3，（words=20，后面会讲）；</li><li>length()：表示BitSet空间大小，如10100，length=5；</li></ol><p>初始化BitSet时，会计算需要多少个long数组，64位以内可以使用一个words存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BitSet</span><span class="params">(<span class="keyword">int</span> nbits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// nbits can't be negative; size 0 is OK</span></span><br><span class="line">        <span class="keyword">if</span> (nbits &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NegativeArraySizeException(<span class="string">"nbits &lt; 0: "</span> + nbits);</span><br><span class="line">        initWords(nbits);</span><br><span class="line">        sizeIsSticky = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initWords</span><span class="params">(<span class="keyword">int</span> nbits)</span> </span>&#123;</span><br><span class="line">        words = <span class="keyword">new</span> <span class="keyword">long</span>[wordIndex(nbits-<span class="number">1</span>) + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wordIndex</span><span class="params">(<span class="keyword">int</span> bitIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bitIndex &gt;&gt; <span class="number">6</span>;<span class="comment">//位运算，向右移动6位，小于64都是0</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当设置一个bit位时，看这个数字在多少位，如2则第二位为1，即10，,3则第三位为1，即100，可见算法为<code>1&lt;&lt;n</code>(n为set参数)； 其中，<code>words</code>的值为<code>words |= (1&lt;&lt;n)</code>，位或运算<br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BitSet bitSet &#x3D; new BitSet(64);</span><br><span class="line">bitSet.set(2, true);&#x2F;&#x2F; words &#x3D; 4(二进制：100），数组&#x3D;&#123;2&#125;</span><br><span class="line">bitSet.set(1, true);&#x2F;&#x2F; words &#x3D; 6(二进制：110），数组&#x3D;&#123;1,2&#125;</span><br><span class="line">bitSet.set(4, true);&#x2F;&#x2F; words &#x3D; 22(二进制：1110），数组&#x3D;&#123;1,2,4&#125;</span><br></pre></td></tr></table></figure><p>因此，可用BitSet进行排重，排序等</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fescar 分布式框架原理</title>
      <link href="/2019/12/30/Fescar-%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"/>
      <url>/2019/12/30/Fescar-%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>FESCAR（Fast &amp; Easy Commit And Rollback） 是一个用于微服务架构的分布式事务解决方案，它的特点是高性能且易于使用，旨在实现简单并快速的事务提交与回滚。</p><h4 id="思想-amp-机制："><a href="#思想-amp-机制：" class="headerlink" title="思想&amp;机制："></a>思想&amp;机制：</h4><p>Fescar 是用于解决微服务架构中的事务问题。<br>我们知道一般解决微服务下的事务问题有以下几种解决思路</p><ol><li>2PC或者3PC，即两阶段提交、三阶段提交。</li><li>TCC -Try Confirm Cancel。</li><li>事务型MQ。</li></ol><p>而Fescar 虽然也是属于两阶段提交，但跟以上又有点不一样，Fescar是一种补偿性事务机制；它由以下三块组成：</p><ul><li>Transaction Coordinator(TC)：维护全局和分支事务的状态，驱动全局事务提交与回滚。</li><li>Transaction Manager(TM)：定义全局事务的范围：开始、提交或回滚全局事务。</li><li>Resource Manager(RM)：管理分支事务处理的资源，与TC通信以注册分支事务并报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p><img src="https://thumbnail0.baidupcs.com/thumbnail/f55f04f6eh48fa890c6d64ae0f8d4169?fid=269699459-250528-167107243877936&time=1577710800&rt=sh&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-F%2F7bhtX7tLwRfM9vXgFvAfyNgX8%3D&expires=8h&chkv=0&chkbd=0&chkpc=&dp-logid=8439972494770383992&dp-callid=0&size=c710_u400&quality=100&vuk=-&ft=video" alt="图片"></p><p>Fescar管理分布式事务的典型生命周期：</p><ol><li>TM 要求 TC 开始新的全局事务，TC 生成表示全局事务的 XID。</li><li>XID 通过微服务的调用链传播。</li><li>RM 在 TC 中将本地事务注册为 XID 的相应全局事务的分支。</li><li>TM 要求 TC 提交或回滚 XID 的相应全局事务。</li><li>TC 驱动 XID 的相应全局事务下的所有分支事务，完成分支提交或回滚。</li></ol><p>TM和RM向TC注册，TM RPC调用RM生成日志并返回信息给TM，TM发送指令，全部提交或回滚。<br>使用nettry作为TM、RM与TC的通信服务器，进行指令的发送；TC目前是单机模式</p><p><strong>原理:</strong></br><br>&emsp;&emsp;Fescar通过控制Datasource、Connection、Prestatement、(insert\update\delete)Exector来控制整个数据的事务，通过扩展生成相应的代理，来保证整个过程的可控。在每个子事务的提交过程中，对每个事务语句都生产undolog保存在mysql中，undolog会记录提交前后的快照信息，以便后期回滚操作，因为是回滚快照，所以中间不得有其他事务对数据进行干扰；Fescar的每个分支事务会向总TC申请全局锁，锁的组成为表名+主键（相当于是行级锁了）以保证不同事务的隔离。这种隔离方式要求所有操作该记录的实例都必须使用Fescar，但是如果一个未使用Fescar的连接更新数据，导致快照和数据不一致呢？Fescar会报错，交给业务方TM自己处理</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数取个好名字</title>
      <link href="/2019/12/29/%E5%87%BD%E6%95%B0%E5%8F%96%E4%B8%AA%E5%A5%BD%E5%90%8D%E5%AD%97/"/>
      <url>/2019/12/29/%E5%87%BD%E6%95%B0%E5%8F%96%E4%B8%AA%E5%A5%BD%E5%90%8D%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;重构是个技术活，特别是取名字，一个好的名字可以省去很多注释代码，一个好的项目见名知意；所以这边搜罗了一些取名字的字典</p><h4 id="常用动词表"><a href="#常用动词表" class="headerlink" title="常用动词表"></a>常用动词表</h4><table><thead><tr><th>类别</th><th align="right">单词</th></tr></thead><tbody><tr><td>添加/插入/创建/初始化/加载</td><td align="right">add、append、insert、create、initialize、load</td></tr><tr><td>删除/销毁</td><td align="right">delete、remove、destroy、drop</td></tr><tr><td>打开/开始/启动</td><td align="right">open、start</td></tr><tr><td>关闭/停止</td><td align="right">close、stop</td></tr><tr><td>获取/读取/查找/查询</td><td align="right">get、fetch、acquire、read、search、find、query</td></tr><tr><td>设置/重置/放入/写入/释放/刷新</td><td align="right">set、reset、put、write、release、refresh</td></tr><tr><td>发送/推送</td><td align="right">send、push</td></tr><tr><td>接收/拉取</td><td align="right">receive、pull</td></tr><tr><td>提交/撤销/取消</td><td align="right">submit、cancel</td></tr><tr><td>收集/采集/选取/选择</td><td align="right">collect、pick、select</td></tr><tr><td>提取/解析</td><td align="right">sub、extract、parse</td></tr><tr><td>编码/解码</td><td align="right">encode、decode</td></tr><tr><td>填充/打包/压缩</td><td align="right">fill、pack、compress</td></tr><tr><td>清空/拆包/解压</td><td align="right">flush、clear、unpack、decompress</td></tr><tr><td>增加/减少</td><td align="right">increase、decrease、reduce</td></tr><tr><td>分隔/拼接</td><td align="right">split、join、concat</td></tr><tr><td>过滤/校验/检测/审核/通过</td><td align="right">filter、valid、check、audit、adopt</td></tr></tbody></table><h4 id="常用名词表"><a href="#常用名词表" class="headerlink" title="常用名词表"></a>常用名词表</h4><table><thead><tr><th>类别</th><th align="right">单词</th></tr></thead><tbody><tr><td>容量/大小/长度</td><td align="right">capacity、size、length</td></tr><tr><td>实例/上下文</td><td align="right">instance、context</td></tr><tr><td>配置</td><td align="right">config、settings</td></tr><tr><td>头部/前面/前一个/第一个</td><td align="right">header、front、previous、first</td></tr><tr><td>尾部/后面/后一个/最后一个</td><td align="right">tail、back、next、last</td></tr><tr><td>区间/区域/某一部分/范围/规模</td><td align="right">range、interval、region、area、section、scope、scale</td></tr><tr><td>缓存/缓冲/会话</td><td align="right">cache、buffer、session</td></tr><tr><td>本地/局部/全局</td><td align="right">local、global</td></tr><tr><td>成员/元素</td><td align="right">member、element</td></tr><tr><td>菜单/列表</td><td align="right">menu、list</td></tr><tr><td>源/目标</td><td align="right">source、destination、target</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原码、补码、反码</title>
      <link href="/2019/12/29/%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81/"/>
      <url>/2019/12/29/%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在计算机内部，所有的信息都是以二进制形式存在的，这最原始的二进制即为<strong>原码</strong><br>如整数 10 （int 占四个字节，一个字节为8个bit），在计算机内部二进制表示为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 00001010.</span><br></pre></td></tr></table></figure><p>但是数字有正负，所以计算机约定，以最高位来标识正负，所以整数<code>-10</code>就表示为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000000 00000000 00000000 00001010.</span><br></pre></td></tr></table></figure><p>但是一个字节的取值范围不是<code>[-128,127]</code>吗？按这理论，应该是<code>[-127,127]</code>啊！这是用<code>-128</code> 代替了 <code>-0</code>(零只有一个嘛)。我们尝试使用二进制来进行数字的运算，如:<code>10+10</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    00000000 00000000 00000000 00001010</span><br><span class="line">+   00000000 00000000 00000000 00001010</span><br><span class="line">-----------------------------------------</span><br><span class="line">&#x3D;   00000000 00000000 00000000 00010100</span><br></pre></td></tr></table></figure><p>结果为<code>20(2^5+2^2)</code>，和预料的相符。<br>如果换成负数呢？我们知道，绝对值相等的正负数，他们的和等于零，<code>10+(-10)=0</code>，拿到计算机内部二级制表示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    00000000 00000000 00000000 00001010</span><br><span class="line">+   10000000 00000000 00000000 00001010</span><br><span class="line">-----------------------------------------</span><br><span class="line">&#x3D;   10000000 00000000 00000000 00010100</span><br></pre></td></tr></table></figure><p>换算成十进制为<code>-20(2^5+2^2)</code>，显然，如果计算机这样计算的话就错了。所以科学家们想出来了另一种解决方法：站在计算机的角度，正数的加法是正确的，而正数加上一个负数却有问题。我们可以设置这样一个数和原码互补，这样两个互补的二进制之和就等于零了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    00000000 00000000 00000000 00001010</span><br><span class="line">+   11111111 11111111 11111111 11110110</span><br><span class="line">-----------------------------------------</span><br><span class="line">&#x3D;   00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><p>这样抛开溢出的一位，就和期望的0相符了。这里和原码形成互补关系的二进制我们称为<strong>补码</strong><br>使用几个运算证实下我们的结论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-4 + (-7):</span><br><span class="line">4：00000000 00000000 00000000 00000100，</span><br><span class="line">7：00000000 00000000 00000000 00000111</span><br><span class="line">(-4补码)：11111111 11111111 11111111 11111100， </span><br><span class="line">(-7补码)：11111111 11111111 11111111 11111001</span><br><span class="line">11：00000000 00000000 00000000 00001011</span><br><span class="line">(-11补码)：11111111 11111111 11111111 11110101</span><br><span class="line"></span><br><span class="line">    11111111 11111111 11111111 11111100</span><br><span class="line">+   11111111 11111111 11111111 11111001</span><br><span class="line">-----------------------------------------</span><br><span class="line">&#x3D;   11111111 11111111 11111111 11110101</span><br></pre></td></tr></table></figure><p>所以我们的结论是可行的，补码和原码互为互补关系。<br>&emsp;&emsp;再次声明一下，所有的这些对于正数来说都是不需要的，正数的原码，反码，补码都是一样的。<br>&emsp;&emsp;那么反码是什么呢？反码比较好理解，就是对原码取反（符号为不变，其他值取反），如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-10</span><br><span class="line">10000000 00000000 00000000 00001010</span><br><span class="line">~(-10)</span><br><span class="line">11111111 11111111 11111111 11110101</span><br><span class="line">-11</span><br><span class="line">10000000 00000000 00000000 00010101</span><br><span class="line">~(-11)</span><br><span class="line">10000000 00000000 00000000 00001010</span><br></pre></td></tr></table></figure><p>这边我们可以发现个规律：补码 = 反码 + 1，你不信可以试试。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/28/hello-world/"/>
      <url>/2019/12/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>

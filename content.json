{"meta":{"title":"From","subtitle":"Amos的文章记录站","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-12-29T08:24:17.000Z","updated":"2019-12-29T09:36:39.297Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"&emsp;&emsp;From主要用于生活工作中的日常记录,有很多也是转载自其他网站，当作一个记录，以防后面忘记，From 生活，From 工作。作者是一名Java程序员，其实更好听一点应该是软件工程师傅，主要专研的是Java后台开发和大数据-数据应用方向。"}],"posts":[{"title":"Java内存模型","slug":"Java内存模型","date":"2020-03-29T10:15:08.000Z","updated":"2020-03-29T10:53:16.586Z","comments":true,"path":"2020/03/29/Java内存模型/","link":"","permalink":"http://yoursite.com/2020/03/29/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"####一.内存模型的相关概念 大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。 也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码： 1i = i + 1; 当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。 这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。 比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？ 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。 最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 为了解决缓存不一致性问题，通常来说有以下2种解决方法： 1）通过在总线加LOCK#锁的方式 2）通过缓存一致性协议 这2种方式都是硬件层面上提供的方式。在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。 但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。 所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 ####二.并发编程中的三个概念 在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：######1.原子性 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 一个很经典的例子就是银行账户转账问题： 比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。 同样地反映到并发编程中会出现什么结果呢？ 举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？ 1i = 9; 假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。 那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。######2.可见性 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 举个简单的例子，看下面这段代码： 12345//线程1执行的代码int i = 0;i = 10;//线程2执行的代码j = i; 假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。 此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。######3.有序性 有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码： 1234int i = 0;boolean flag = false;i = 1; //语句1flag = true; //语句2 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子： 1234int a = 10; //语句1int r = 2; //语句2a = a + 3; //语句3r = a*a; //语句4 这段代码有4个语句，那么可能的一个执行顺序是：2 -&gt; 1 -&gt; 3 -&gt;4 那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子： 12345678//线程1:context = loadContext(); //语句1inited = true; //语句2//线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 ####三.Java内存模型 在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。 在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。 Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。 举个简单的例子：在java中，执行下面这个语句： 1i = 10; 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。 那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？ ######1.原子性 在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i： 请分析以下哪些操作是原子性操作： 1234x = 10; //语句1y = x; //语句2x++; //语句3x = x + 1; //语句4 咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。 所以上面4个语句只有语句1的操作具备原子性。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。######2.可见性 对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 ######3.有序性 在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 下面就来具体介绍下happens-before原则（先行发生原则）：程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 这8条原则摘自《深入理解Java虚拟机》。 这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。 下面我们来解释一下前4条规则： 对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。 第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。 第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 第四条规则实际上就是体现happens-before原则具备传递性。####四.深入剖析volatile关键字 在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。 volatile关键字的两层语义一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 1) 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 2) 禁止进行指令重排序。 先看一段代码，假如线程1先执行，线程2后执行：1234567//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125;//线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一：使用volatile关键字会强制将修改的值立即写入主存； 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。那么线程1读取到的就是最新的正确的值。 volatile保证原子性吗？ 从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？ 下面看一个例子：1234567891011121314151617181920public class Test &#123; public volatile int inc = 0; public void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。 可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现： 假如某个时刻变量inc的值为10， 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。 根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。 把上面的代码改成以下任何一种都可以达到效果： 采用synchronized：1234567891011121314151617181920public class Test &#123; public int inc = 0; public synchronized void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 采用Lock：1234567891011121314151617181920212223242526public class Test &#123; public int inc = 0; Lock lock = new ReentrantLock(); public void increase() &#123; lock.lock(); try &#123; inc++; &#125; finally&#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 采用AtomicInteger：1234567891011121314151617181920public class Test &#123; public AtomicInteger inc = new AtomicInteger(); public void increase() &#123; inc.getAndIncrement(); &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 3.volatile能保证有序性吗？ 在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile关键字禁止指令重排序有两层意思： 1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 可能上面说的比较绕，举个简单的例子： 12345678//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 那么我们回到前面举的一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 4.volatile的原理和实现机制 前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。 下面这段话摘自《深入理解Java虚拟机》： “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 2）它会强制将对缓存的修改操作立即写入主存； 3）如果是写操作，它会导致其他CPU中对应的缓存行无效。 五.使用volatile关键字的场景 synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： 1）对变量的写操作不依赖于当前值 2）该变量没有包含在具有其他变量的不变式中 实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。 下面列举几个Java中使用volatile的几个场景。 1.状态标记量 1234567volatile boolean flag = false;while(!flag)&#123; doSomething();&#125;public void setFlag() &#123; flag = true;&#125; 12345678910volatile boolean inited = false;//线程1:context = loadContext(); inited = true; //线程2:while(!inited )&#123;sleep()&#125;doSomethingwithconfig(context); 2.double check 1234567891011121314class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 转载自：&lt;https://www.cnblogs.com/dolphin0520/p/3920373.html","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"非原创","slug":"非原创","permalink":"http://yoursite.com/tags/%E9%9D%9E%E5%8E%9F%E5%88%9B/"}]},{"title":"System.getProperty所拥有的属性","slug":"System-getProperty所拥有的属性","date":"2020-01-05T12:04:42.000Z","updated":"2020-01-05T12:05:44.634Z","comments":true,"path":"2020/01/05/System-getProperty所拥有的属性/","link":"","permalink":"http://yoursite.com/2020/01/05/System-getProperty%E6%89%80%E6%8B%A5%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7/","excerpt":"","text":"12345678910111213141516171819202122232425262728java.version Java 运行时环境版本java.vendor Java 运行时环境供应商java.vendor.url Java 供应商的 URLjava.home Java 安装目录java.vm.specification.version Java 虚拟机规范版本java.vm.specification.vendor Java 虚拟机规范供应商java.vm.specification.name Java 虚拟机规范名称java.vm.version Java 虚拟机实现版本java.vm.vendor Java 虚拟机实现供应商java.vm.name Java 虚拟机实现名称java.specification.version Java 运行时环境规范版本java.specification.vendor Java 运行时环境规范供应商java.specification.name Java 运行时环境规范名称java.class.version Java 类格式版本号java.class.path Java 类路径java.library.path 加载库时搜索的路径列表java.io.tmpdir 默认的临时文件路径java.compiler 要使用的 JIT 编译器的名称java.ext.dirs 一个或多个扩展目录的路径os.name 操作系统的名称os.arch 操作系统的架构os.version 操作系统的版本file.separator 文件分隔符（在 UNIX 系统中是“&#x2F;”）path.separator 路径分隔符（在 UNIX 系统中是“:”）line.separator 行分隔符（在 UNIX 系统中是“&#x2F;n”）user.name 用户的账户名称user.home 用户的主目录user.dir 用户的当前工作目录","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Java8 根据属性值去重","slug":"Java8-根据属性值去重","date":"2020-01-05T11:57:15.000Z","updated":"2020-01-05T12:03:04.320Z","comments":true,"path":"2020/01/05/Java8-根据属性值去重/","link":"","permalink":"http://yoursite.com/2020/01/05/Java8-%E6%A0%B9%E6%8D%AE%E5%B1%9E%E6%80%A7%E5%80%BC%E5%8E%BB%E9%87%8D/","excerpt":"","text":"1234public static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, Object&gt; keyExtractor) &#123; Map&lt;Object, Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;(); return object -&gt; seen.putIfAbsent(keyExtractor.apply(object), Boolean.TRUE) == null;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"}]},{"title":"Docker启动Hadoop报错","slug":"Docker启动Hadoop报错","date":"2020-01-05T11:51:44.000Z","updated":"2020-01-05T11:56:13.776Z","comments":true,"path":"2020/01/05/Docker启动Hadoop报错/","link":"","permalink":"http://yoursite.com/2020/01/05/Docker%E5%90%AF%E5%8A%A8Hadoop%E6%8A%A5%E9%94%99/","excerpt":"","text":"使用docker启动hadoop时，报以下错误 1234[xhw@192 ~]$ docker run -p9000:9000 -it sequenceiq/hadoop-docker:latest -bashWARNING: IPv4 forwarding is disabled. Networking will not work.docker: Error response from daemon: driver failed programming external connectivity on endpoint hungry_neumann (b5668ce9501b598dbe879cac6353831964cc073997305f7d16376a3abb840de7): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 9000 -j DNAT --to-destination 172.17.0.2:9000 ! -i docker0: iptables: No chain/target/match by that name. (exit status 1)). 原因：docker 服务启动的时候，docker服务会向iptables注册一个链，以便让docker服务管理的containner所暴露的端口之间进行通信，通过命令iptables -L可以查看iptables 链报这个错应该是iptables被改变或者什么的，所以只要重启docker服务，重新加载iptable链即可 1[xhw@192 ~]$ service docker restart","categories":[{"name":"容器","slug":"容器","permalink":"http://yoursite.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"经验","slug":"经验","permalink":"http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C/"}]},{"title":"Linux下SonarQube搭建","slug":"Linux下SonarQube搭建","date":"2020-01-03T13:37:32.000Z","updated":"2020-03-29T10:52:26.195Z","comments":true,"path":"2020/01/03/Linux下SonarQube搭建/","link":"","permalink":"http://yoursite.com/2020/01/03/Linux%E4%B8%8BSonarQube%E6%90%AD%E5%BB%BA/","excerpt":"","text":"SonarQube支持多种语言的检测，内部使用了ElasticSearch用于搜索。注意：ElasticSearch不能使用root用户启动，所以需要使用其他用户。以下在Centos下搭建SonarQube步骤 安装JDK1.8，高级版本的SonarQube使用的JDK1.8，安装Centos是会可以选择自动安装。 可以新建一个目录存放下载的SonarQube压缩文件，这边下载的是7.2.1版本。 1[xhw@192 ~]$ wget https://sonarsource.bintray.com/Distribution/sonarqube/sonarqube-7.2.1.zip 解压下载的zip文件 1[xhw@192 ~]$ unzip sonarqube-7.2.1.zip 安装中文插件 12[xhw@192 ~]$ cd sonarqube-7.2.1/extensions/plugins[xhw@192 plugins]$ wget https://github.com/SonarQubeCommunity/sonar-l10n-zh/releases/download/sonar-l10n-zh-plugin-1.22/sonar-l10n-zh-plugin-1.22.jar 使用mysql数据存储数据，先建sonar数据库，然后修改sonar.properties。mysql版本应大于5.5小于8（编辑时意外退出会出现swap文件，使用：ll -a 显示然后删除即可）mysql用户如果要支持远程登录的，需要将用户表的host改为%，并刷新。 12SELECT * from mysql.user;flush PRIVILEGES; 12345[xhw@192 ~]$ cd sonarqube-7.2.1/conf/[xhw@192 conf]$ vim sonar.properties sonar.jdbc.username=rootsonar.jdbc.password=rootsonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false 启动sonar（有时候第二次以上启动会启动失败，应删除tmp和logs文件夹就可以了） 123[xhw@192 ~]$ cd sonarqube-7.2.1/bin/linux-x86-64/[xhw@192 linux-x86-64]$ ./sonar.sh start[xhw@192 linux-x86-64]$ ./sonar.sh stop ##停止服务 MySql：下载安装12https:&#x2F;&#x2F;dev.mysql.com&#x2F;downloads&#x2F;installer&#x2F;https:&#x2F;&#x2F;cdn.mysql.com&#x2F;&#x2F;Downloads&#x2F;MySQLInstaller&#x2F;mysql-installer-community-5.7.22.1.msi 基于maven进行代码检查 maven的setting.xml文件加入profile12345678910111213&lt;pluginGroup&gt;org.sonarsource.scanner.maven&lt;/pluginGroup&gt; &lt;profile&gt; &lt;id&gt;sonar&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;!-- 配置 Sonar Host地址，默认：http://localhost:9000 --&gt; &lt;sonar.host.url&gt; http://localhost:9000 &lt;/sonar.host.url&gt; &lt;/properties&gt; &lt;/profile&gt; pom.xml文件加入插件123456789&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.sonarsource.scanner.maven&lt;/groupId&gt; &lt;artifactId&gt;sonar-maven-plugin&lt;/artifactId&gt; &lt;version&gt;3.3.0.603&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;","categories":[{"name":"安装","slug":"安装","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"SonarQube","slug":"SonarQube","permalink":"http://yoursite.com/tags/SonarQube/"}]},{"title":"Java之BitSet","slug":"Java之BitSet","date":"2020-01-02T13:07:43.000Z","updated":"2020-01-02T13:16:34.806Z","comments":true,"path":"2020/01/02/Java之BitSet/","link":"","permalink":"http://yoursite.com/2020/01/02/Java%E4%B9%8BBitSet/","excerpt":"","text":"BitSet通过位运算进行数据的标示，内部使用long数组进行存储，即64位bit。有两个方法需要注意： size()：表示BitSet实际使用的空间数，如10100，占用空间数为3，（words=20，后面会讲）； length()：表示BitSet空间大小，如10100，length=5； 初始化BitSet时，会计算需要多少个long数组，64位以内可以使用一个words存。 123456789101112131415public BitSet(int nbits) &#123; // nbits can't be negative; size 0 is OK if (nbits &lt; 0) throw new NegativeArraySizeException(\"nbits &lt; 0: \" + nbits); initWords(nbits); sizeIsSticky = true; &#125;​ private void initWords(int nbits) &#123; words = new long[wordIndex(nbits-1) + 1]; &#125;​ private static int wordIndex(int bitIndex) &#123; return bitIndex &gt;&gt; 6;//位运算，向右移动6位，小于64都是0 &#125; 当设置一个bit位时，看这个数字在多少位，如2则第二位为1，即10，,3则第三位为1，即100，可见算法为1&lt;&lt;n(n为set参数)； 其中，words的值为words |= (1&lt;&lt;n)，位或运算如： 1234BitSet bitSet &#x3D; new BitSet(64);bitSet.set(2, true);&#x2F;&#x2F; words &#x3D; 4(二进制：100），数组&#x3D;&#123;2&#125;bitSet.set(1, true);&#x2F;&#x2F; words &#x3D; 6(二进制：110），数组&#x3D;&#123;1,2&#125;bitSet.set(4, true);&#x2F;&#x2F; words &#x3D; 22(二进制：1110），数组&#x3D;&#123;1,2,4&#125; 因此，可用BitSet进行排重，排序等","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"Fescar 分布式框架原理","slug":"Fescar-分布式框架原理","date":"2019-12-30T13:26:28.000Z","updated":"2019-12-30T14:08:24.817Z","comments":true,"path":"2019/12/30/Fescar-分布式框架原理/","link":"","permalink":"http://yoursite.com/2019/12/30/Fescar-%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/","excerpt":"","text":"FESCAR（Fast &amp; Easy Commit And Rollback） 是一个用于微服务架构的分布式事务解决方案，它的特点是高性能且易于使用，旨在实现简单并快速的事务提交与回滚。 思想&amp;机制：Fescar 是用于解决微服务架构中的事务问题。我们知道一般解决微服务下的事务问题有以下几种解决思路 2PC或者3PC，即两阶段提交、三阶段提交。 TCC -Try Confirm Cancel。 事务型MQ。 而Fescar 虽然也是属于两阶段提交，但跟以上又有点不一样，Fescar是一种补偿性事务机制；它由以下三块组成： Transaction Coordinator(TC)：维护全局和分支事务的状态，驱动全局事务提交与回滚。 Transaction Manager(TM)：定义全局事务的范围：开始、提交或回滚全局事务。 Resource Manager(RM)：管理分支事务处理的资源，与TC通信以注册分支事务并报告分支事务的状态，并驱动分支事务提交或回滚。 Fescar管理分布式事务的典型生命周期： TM 要求 TC 开始新的全局事务，TC 生成表示全局事务的 XID。 XID 通过微服务的调用链传播。 RM 在 TC 中将本地事务注册为 XID 的相应全局事务的分支。 TM 要求 TC 提交或回滚 XID 的相应全局事务。 TC 驱动 XID 的相应全局事务下的所有分支事务，完成分支提交或回滚。 TM和RM向TC注册，TM RPC调用RM生成日志并返回信息给TM，TM发送指令，全部提交或回滚。使用nettry作为TM、RM与TC的通信服务器，进行指令的发送；TC目前是单机模式 原理:&emsp;&emsp;Fescar通过控制Datasource、Connection、Prestatement、(insert\\update\\delete)Exector来控制整个数据的事务，通过扩展生成相应的代理，来保证整个过程的可控。在每个子事务的提交过程中，对每个事务语句都生产undolog保存在mysql中，undolog会记录提交前后的快照信息，以便后期回滚操作，因为是回滚快照，所以中间不得有其他事务对数据进行干扰；Fescar的每个分支事务会向总TC申请全局锁，锁的组成为表名+主键（相当于是行级锁了）以保证不同事务的隔离。这种隔离方式要求所有操作该记录的实例都必须使用Fescar，但是如果一个未使用Fescar的连接更新数据，导致快照和数据不一致呢？Fescar会报错，交给业务方TM自己处理","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"原理","slug":"原理","permalink":"http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"}]},{"title":"函数取个好名字","slug":"函数取个好名字","date":"2019-12-29T12:44:29.000Z","updated":"2019-12-30T13:30:11.494Z","comments":true,"path":"2019/12/29/函数取个好名字/","link":"","permalink":"http://yoursite.com/2019/12/29/%E5%87%BD%E6%95%B0%E5%8F%96%E4%B8%AA%E5%A5%BD%E5%90%8D%E5%AD%97/","excerpt":"","text":"&emsp;&emsp;重构是个技术活，特别是取名字，一个好的名字可以省去很多注释代码，一个好的项目见名知意；所以这边搜罗了一些取名字的字典 常用动词表 类别 单词 添加/插入/创建/初始化/加载 add、append、insert、create、initialize、load 删除/销毁 delete、remove、destroy、drop 打开/开始/启动 open、start 关闭/停止 close、stop 获取/读取/查找/查询 get、fetch、acquire、read、search、find、query 设置/重置/放入/写入/释放/刷新 set、reset、put、write、release、refresh 发送/推送 send、push 接收/拉取 receive、pull 提交/撤销/取消 submit、cancel 收集/采集/选取/选择 collect、pick、select 提取/解析 sub、extract、parse 编码/解码 encode、decode 填充/打包/压缩 fill、pack、compress 清空/拆包/解压 flush、clear、unpack、decompress 增加/减少 increase、decrease、reduce 分隔/拼接 split、join、concat 过滤/校验/检测/审核/通过 filter、valid、check、audit、adopt 常用名词表 类别 单词 容量/大小/长度 capacity、size、length 实例/上下文 instance、context 配置 config、settings 头部/前面/前一个/第一个 header、front、previous、first 尾部/后面/后一个/最后一个 tail、back、next、last 区间/区域/某一部分/范围/规模 range、interval、region、area、section、scope、scale 缓存/缓冲/会话 cache、buffer、session 本地/局部/全局 local、global 成员/元素 member、element 菜单/列表 menu、list 源/目标 source、destination、target","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"重构","slug":"重构","permalink":"http://yoursite.com/tags/%E9%87%8D%E6%9E%84/"}]},{"title":"原码、补码、反码","slug":"原码、补码、反码","date":"2019-12-29T12:11:26.000Z","updated":"2019-12-30T13:30:18.186Z","comments":true,"path":"2019/12/29/原码、补码、反码/","link":"","permalink":"http://yoursite.com/2019/12/29/%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81/","excerpt":"","text":"&emsp;&emsp;在计算机内部，所有的信息都是以二进制形式存在的，这最原始的二进制即为原码如整数 10 （int 占四个字节，一个字节为8个bit），在计算机内部二进制表示为 100000000 00000000 00000000 00001010. 但是数字有正负，所以计算机约定，以最高位来标识正负，所以整数-10就表示为 110000000 00000000 00000000 00001010. 但是一个字节的取值范围不是[-128,127]吗？按这理论，应该是[-127,127]啊！这是用-128 代替了 -0(零只有一个嘛)。我们尝试使用二进制来进行数字的运算，如:10+10 1234 00000000 00000000 00000000 00001010+ 00000000 00000000 00000000 00001010-----------------------------------------&#x3D; 00000000 00000000 00000000 00010100 结果为20(2^5+2^2)，和预料的相符。如果换成负数呢？我们知道，绝对值相等的正负数，他们的和等于零，10+(-10)=0，拿到计算机内部二级制表示为： 1234 00000000 00000000 00000000 00001010+ 10000000 00000000 00000000 00001010-----------------------------------------&#x3D; 10000000 00000000 00000000 00010100 换算成十进制为-20(2^5+2^2)，显然，如果计算机这样计算的话就错了。所以科学家们想出来了另一种解决方法：站在计算机的角度，正数的加法是正确的，而正数加上一个负数却有问题。我们可以设置这样一个数和原码互补，这样两个互补的二进制之和就等于零了。 1234 00000000 00000000 00000000 00001010+ 11111111 11111111 11111111 11110110-----------------------------------------&#x3D; 00000000 00000000 00000000 00000000 这样抛开溢出的一位，就和期望的0相符了。这里和原码形成互补关系的二进制我们称为补码使用几个运算证实下我们的结论 123456789101112-4 + (-7):4：00000000 00000000 00000000 00000100，7：00000000 00000000 00000000 00000111(-4补码)：11111111 11111111 11111111 11111100， (-7补码)：11111111 11111111 11111111 1111100111：00000000 00000000 00000000 00001011(-11补码)：11111111 11111111 11111111 11110101 11111111 11111111 11111111 11111100+ 11111111 11111111 11111111 11111001-----------------------------------------&#x3D; 11111111 11111111 11111111 11110101 所以我们的结论是可行的，补码和原码互为互补关系。&emsp;&emsp;再次声明一下，所有的这些对于正数来说都是不需要的，正数的原码，反码，补码都是一样的。&emsp;&emsp;那么反码是什么呢？反码比较好理解，就是对原码取反（符号为不变，其他值取反），如 12345678-1010000000 00000000 00000000 00001010~(-10)11111111 11111111 11111111 11110101-1110000000 00000000 00000000 00010101~(-11)10000000 00000000 00000000 00001010 这边我们可以发现个规律：补码 = 反码 + 1，你不信可以试试。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"原理","slug":"原理","permalink":"http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-12-28T12:22:45.895Z","updated":"2020-01-05T11:52:48.926Z","comments":true,"path":"2019/12/28/hello-world/","link":"","permalink":"http://yoursite.com/2019/12/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"建站","slug":"建站","permalink":"http://yoursite.com/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[]}]}
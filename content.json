{"meta":{"title":"From","subtitle":"Amos的文章记录站","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-12-29T08:24:17.000Z","updated":"2019-12-29T09:36:39.297Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"&emsp;&emsp;From主要用于生活工作中的日常记录,有很多也是转载自其他网站，当作一个记录，以防后面忘记，From 生活，From 工作。作者是一名Java程序员，其实更好听一点应该是软件工程师傅，主要专研的是Java后台开发和大数据-数据应用方向。"}],"posts":[{"title":"System.getProperty所拥有的属性","slug":"System-getProperty所拥有的属性","date":"2020-01-05T12:04:42.000Z","updated":"2020-01-05T12:05:44.634Z","comments":true,"path":"2020/01/05/System-getProperty所拥有的属性/","link":"","permalink":"http://yoursite.com/2020/01/05/System-getProperty%E6%89%80%E6%8B%A5%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7/","excerpt":"","text":"12345678910111213141516171819202122232425262728java.version Java 运行时环境版本java.vendor Java 运行时环境供应商java.vendor.url Java 供应商的 URLjava.home Java 安装目录java.vm.specification.version Java 虚拟机规范版本java.vm.specification.vendor Java 虚拟机规范供应商java.vm.specification.name Java 虚拟机规范名称java.vm.version Java 虚拟机实现版本java.vm.vendor Java 虚拟机实现供应商java.vm.name Java 虚拟机实现名称java.specification.version Java 运行时环境规范版本java.specification.vendor Java 运行时环境规范供应商java.specification.name Java 运行时环境规范名称java.class.version Java 类格式版本号java.class.path Java 类路径java.library.path 加载库时搜索的路径列表java.io.tmpdir 默认的临时文件路径java.compiler 要使用的 JIT 编译器的名称java.ext.dirs 一个或多个扩展目录的路径os.name 操作系统的名称os.arch 操作系统的架构os.version 操作系统的版本file.separator 文件分隔符（在 UNIX 系统中是“&#x2F;”）path.separator 路径分隔符（在 UNIX 系统中是“:”）line.separator 行分隔符（在 UNIX 系统中是“&#x2F;n”）user.name 用户的账户名称user.home 用户的主目录user.dir 用户的当前工作目录","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[]},{"title":"Java8 根据属性值去重","slug":"Java8-根据属性值去重","date":"2020-01-05T11:57:15.000Z","updated":"2020-01-05T12:03:04.320Z","comments":true,"path":"2020/01/05/Java8-根据属性值去重/","link":"","permalink":"http://yoursite.com/2020/01/05/Java8-%E6%A0%B9%E6%8D%AE%E5%B1%9E%E6%80%A7%E5%80%BC%E5%8E%BB%E9%87%8D/","excerpt":"","text":"1234public static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, Object&gt; keyExtractor) &#123; Map&lt;Object, Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;(); return object -&gt; seen.putIfAbsent(keyExtractor.apply(object), Boolean.TRUE) == null;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"}]},{"title":"Docker启动Hadoop报错","slug":"Docker启动Hadoop报错","date":"2020-01-05T11:51:44.000Z","updated":"2020-01-05T11:56:13.776Z","comments":true,"path":"2020/01/05/Docker启动Hadoop报错/","link":"","permalink":"http://yoursite.com/2020/01/05/Docker%E5%90%AF%E5%8A%A8Hadoop%E6%8A%A5%E9%94%99/","excerpt":"","text":"使用docker启动hadoop时，报以下错误 1234[xhw@192 ~]$ docker run -p9000:9000 -it sequenceiq/hadoop-docker:latest -bashWARNING: IPv4 forwarding is disabled. Networking will not work.docker: Error response from daemon: driver failed programming external connectivity on endpoint hungry_neumann (b5668ce9501b598dbe879cac6353831964cc073997305f7d16376a3abb840de7): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 9000 -j DNAT --to-destination 172.17.0.2:9000 ! -i docker0: iptables: No chain/target/match by that name. (exit status 1)). 原因：docker 服务启动的时候，docker服务会向iptables注册一个链，以便让docker服务管理的containner所暴露的端口之间进行通信，通过命令iptables -L可以查看iptables 链报这个错应该是iptables被改变或者什么的，所以只要重启docker服务，重新加载iptable链即可 1[xhw@192 ~]$ service docker restart","categories":[{"name":"容器","slug":"容器","permalink":"http://yoursite.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"经验","slug":"经验","permalink":"http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C/"}]},{"title":"Linux下SonarQube搭建","slug":"Linux下SonarQube搭建","date":"2020-01-03T13:37:32.000Z","updated":"2020-01-05T11:44:03.700Z","comments":true,"path":"2020/01/03/Linux下SonarQube搭建/","link":"","permalink":"http://yoursite.com/2020/01/03/Linux%E4%B8%8BSonarQube%E6%90%AD%E5%BB%BA/","excerpt":"","text":"SonarQube支持多种语言的检测，内部使用了ElasticSearch用于搜索。注意：ElasticSearch不能使用root用户启动，所以需要使用其他用户。以下在Centos下搭建SonarQube步骤 安装JDK1.8，高级版本的SonarQube使用的JDK1.8，安装Centos是会可以选择自动安装。 可以新建一个目录存放下载的SonarQube压缩文件，这边下载的是7.2.1版本。 1[xhw@192 ~]$ wget https://sonarsource.bintray.com/Distribution/sonarqube/sonarqube-7.2.1.zip 解压下载的zip文件 1[xhw@192 ~]$ unzip sonarqube-7.2.1.zip 安装中文插件 12[xhw@192 ~]$ cd sonarqube-7.2.1/extensions/plugins[xhw@192 plugins]$ wget https://github.com/SonarQubeCommunity/sonar-l10n-zh/releases/download/sonar-l10n-zh-plugin-1.22/sonar-l10n-zh-plugin-1.22.jar 使用mysql数据存储数据，先建sonar数据库，然后修改sonar.properties。mysql版本应大于5.5小于8（编辑时意外退出会出现swap文件，使用：ll -a 显示然后删除即可）mysql用户如果要支持远程登录的，需要将用户表的host改为%，并刷新。 12SELECT * from mysql.user;flush PRIVILEGES; 12345[xhw@192 ~]$ cd sonarqube-7.2.1/conf/[xhw@192 conf]$ vim sonar.properties sonar.jdbc.username=rootsonar.jdbc.password=rootsonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false 启动sonar（有时候第二次以上启动会启动失败，应删除tmp和logs文件夹就可以了） 123[xhw@192 ~]$ cd sonarqube-7.2.1/bin/linux-x86-64/[xhw@192 linux-x86-64]$ ./sonar.sh start[xhw@192 linux-x86-64]$ ./sonar.sh stop ##停止服务 MySql：下载安装12https:&#x2F;&#x2F;dev.mysql.com&#x2F;downloads&#x2F;installer&#x2F;https:&#x2F;&#x2F;cdn.mysql.com&#x2F;&#x2F;Downloads&#x2F;MySQLInstaller&#x2F;mysql-installer-community-5.7.22.1.msi 基于maven进行代码检查 maven的setting.xml文件加入profile12345678910111213&lt;pluginGroup&gt;org.sonarsource.scanner.maven&lt;/pluginGroup&gt; &lt;profile&gt; &lt;id&gt;sonar&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;!-- 配置 Sonar Host地址，默认：http://localhost:9000 --&gt; &lt;sonar.host.url&gt; http://localhost:9000 &lt;/sonar.host.url&gt; &lt;/properties&gt; &lt;/profile&gt; pom.xml文件加入插件123456789&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.sonarsource.scanner.maven&lt;/groupId&gt; &lt;artifactId&gt;sonar-maven-plugin&lt;/artifactId&gt; &lt;version&gt;3.3.0.603&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;","categories":[{"name":"安装","slug":"安装","permalink":"http://yoursite.com/categories/%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"SonarQube","slug":"SonarQube","permalink":"http://yoursite.com/tags/SonarQube/"}]},{"title":"Java之BitSet","slug":"Java之BitSet","date":"2020-01-02T13:07:43.000Z","updated":"2020-01-02T13:16:34.806Z","comments":true,"path":"2020/01/02/Java之BitSet/","link":"","permalink":"http://yoursite.com/2020/01/02/Java%E4%B9%8BBitSet/","excerpt":"","text":"BitSet通过位运算进行数据的标示，内部使用long数组进行存储，即64位bit。有两个方法需要注意： size()：表示BitSet实际使用的空间数，如10100，占用空间数为3，（words=20，后面会讲）； length()：表示BitSet空间大小，如10100，length=5； 初始化BitSet时，会计算需要多少个long数组，64位以内可以使用一个words存。 123456789101112131415public BitSet(int nbits) &#123; // nbits can't be negative; size 0 is OK if (nbits &lt; 0) throw new NegativeArraySizeException(\"nbits &lt; 0: \" + nbits); initWords(nbits); sizeIsSticky = true; &#125;​ private void initWords(int nbits) &#123; words = new long[wordIndex(nbits-1) + 1]; &#125;​ private static int wordIndex(int bitIndex) &#123; return bitIndex &gt;&gt; 6;//位运算，向右移动6位，小于64都是0 &#125; 当设置一个bit位时，看这个数字在多少位，如2则第二位为1，即10，,3则第三位为1，即100，可见算法为1&lt;&lt;n(n为set参数)； 其中，words的值为words |= (1&lt;&lt;n)，位或运算如： 1234BitSet bitSet &#x3D; new BitSet(64);bitSet.set(2, true);&#x2F;&#x2F; words &#x3D; 4(二进制：100），数组&#x3D;&#123;2&#125;bitSet.set(1, true);&#x2F;&#x2F; words &#x3D; 6(二进制：110），数组&#x3D;&#123;1,2&#125;bitSet.set(4, true);&#x2F;&#x2F; words &#x3D; 22(二进制：1110），数组&#x3D;&#123;1,2,4&#125; 因此，可用BitSet进行排重，排序等","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"Fescar 分布式框架原理","slug":"Fescar-分布式框架原理","date":"2019-12-30T13:26:28.000Z","updated":"2019-12-30T14:08:24.817Z","comments":true,"path":"2019/12/30/Fescar-分布式框架原理/","link":"","permalink":"http://yoursite.com/2019/12/30/Fescar-%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/","excerpt":"","text":"FESCAR（Fast &amp; Easy Commit And Rollback） 是一个用于微服务架构的分布式事务解决方案，它的特点是高性能且易于使用，旨在实现简单并快速的事务提交与回滚。 思想&amp;机制：Fescar 是用于解决微服务架构中的事务问题。我们知道一般解决微服务下的事务问题有以下几种解决思路 2PC或者3PC，即两阶段提交、三阶段提交。 TCC -Try Confirm Cancel。 事务型MQ。 而Fescar 虽然也是属于两阶段提交，但跟以上又有点不一样，Fescar是一种补偿性事务机制；它由以下三块组成： Transaction Coordinator(TC)：维护全局和分支事务的状态，驱动全局事务提交与回滚。 Transaction Manager(TM)：定义全局事务的范围：开始、提交或回滚全局事务。 Resource Manager(RM)：管理分支事务处理的资源，与TC通信以注册分支事务并报告分支事务的状态，并驱动分支事务提交或回滚。 Fescar管理分布式事务的典型生命周期： TM 要求 TC 开始新的全局事务，TC 生成表示全局事务的 XID。 XID 通过微服务的调用链传播。 RM 在 TC 中将本地事务注册为 XID 的相应全局事务的分支。 TM 要求 TC 提交或回滚 XID 的相应全局事务。 TC 驱动 XID 的相应全局事务下的所有分支事务，完成分支提交或回滚。 TM和RM向TC注册，TM RPC调用RM生成日志并返回信息给TM，TM发送指令，全部提交或回滚。使用nettry作为TM、RM与TC的通信服务器，进行指令的发送；TC目前是单机模式 原理:&emsp;&emsp;Fescar通过控制Datasource、Connection、Prestatement、(insert\\update\\delete)Exector来控制整个数据的事务，通过扩展生成相应的代理，来保证整个过程的可控。在每个子事务的提交过程中，对每个事务语句都生产undolog保存在mysql中，undolog会记录提交前后的快照信息，以便后期回滚操作，因为是回滚快照，所以中间不得有其他事务对数据进行干扰；Fescar的每个分支事务会向总TC申请全局锁，锁的组成为表名+主键（相当于是行级锁了）以保证不同事务的隔离。这种隔离方式要求所有操作该记录的实例都必须使用Fescar，但是如果一个未使用Fescar的连接更新数据，导致快照和数据不一致呢？Fescar会报错，交给业务方TM自己处理","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"原理","slug":"原理","permalink":"http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"}]},{"title":"函数取个好名字","slug":"函数取个好名字","date":"2019-12-29T12:44:29.000Z","updated":"2019-12-30T13:30:11.494Z","comments":true,"path":"2019/12/29/函数取个好名字/","link":"","permalink":"http://yoursite.com/2019/12/29/%E5%87%BD%E6%95%B0%E5%8F%96%E4%B8%AA%E5%A5%BD%E5%90%8D%E5%AD%97/","excerpt":"","text":"&emsp;&emsp;重构是个技术活，特别是取名字，一个好的名字可以省去很多注释代码，一个好的项目见名知意；所以这边搜罗了一些取名字的字典 常用动词表 类别 单词 添加/插入/创建/初始化/加载 add、append、insert、create、initialize、load 删除/销毁 delete、remove、destroy、drop 打开/开始/启动 open、start 关闭/停止 close、stop 获取/读取/查找/查询 get、fetch、acquire、read、search、find、query 设置/重置/放入/写入/释放/刷新 set、reset、put、write、release、refresh 发送/推送 send、push 接收/拉取 receive、pull 提交/撤销/取消 submit、cancel 收集/采集/选取/选择 collect、pick、select 提取/解析 sub、extract、parse 编码/解码 encode、decode 填充/打包/压缩 fill、pack、compress 清空/拆包/解压 flush、clear、unpack、decompress 增加/减少 increase、decrease、reduce 分隔/拼接 split、join、concat 过滤/校验/检测/审核/通过 filter、valid、check、audit、adopt 常用名词表 类别 单词 容量/大小/长度 capacity、size、length 实例/上下文 instance、context 配置 config、settings 头部/前面/前一个/第一个 header、front、previous、first 尾部/后面/后一个/最后一个 tail、back、next、last 区间/区域/某一部分/范围/规模 range、interval、region、area、section、scope、scale 缓存/缓冲/会话 cache、buffer、session 本地/局部/全局 local、global 成员/元素 member、element 菜单/列表 menu、list 源/目标 source、destination、target","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"重构","slug":"重构","permalink":"http://yoursite.com/tags/%E9%87%8D%E6%9E%84/"}]},{"title":"原码、补码、反码","slug":"原码、补码、反码","date":"2019-12-29T12:11:26.000Z","updated":"2019-12-30T13:30:18.186Z","comments":true,"path":"2019/12/29/原码、补码、反码/","link":"","permalink":"http://yoursite.com/2019/12/29/%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81/","excerpt":"","text":"&emsp;&emsp;在计算机内部，所有的信息都是以二进制形式存在的，这最原始的二进制即为原码如整数 10 （int 占四个字节，一个字节为8个bit），在计算机内部二进制表示为 100000000 00000000 00000000 00001010. 但是数字有正负，所以计算机约定，以最高位来标识正负，所以整数-10就表示为 110000000 00000000 00000000 00001010. 但是一个字节的取值范围不是[-128,127]吗？按这理论，应该是[-127,127]啊！这是用-128 代替了 -0(零只有一个嘛)。我们尝试使用二进制来进行数字的运算，如:10+10 1234 00000000 00000000 00000000 00001010+ 00000000 00000000 00000000 00001010-----------------------------------------&#x3D; 00000000 00000000 00000000 00010100 结果为20(2^5+2^2)，和预料的相符。如果换成负数呢？我们知道，绝对值相等的正负数，他们的和等于零，10+(-10)=0，拿到计算机内部二级制表示为： 1234 00000000 00000000 00000000 00001010+ 10000000 00000000 00000000 00001010-----------------------------------------&#x3D; 10000000 00000000 00000000 00010100 换算成十进制为-20(2^5+2^2)，显然，如果计算机这样计算的话就错了。所以科学家们想出来了另一种解决方法：站在计算机的角度，正数的加法是正确的，而正数加上一个负数却有问题。我们可以设置这样一个数和原码互补，这样两个互补的二进制之和就等于零了。 1234 00000000 00000000 00000000 00001010+ 11111111 11111111 11111111 11110110-----------------------------------------&#x3D; 00000000 00000000 00000000 00000000 这样抛开溢出的一位，就和期望的0相符了。这里和原码形成互补关系的二进制我们称为补码使用几个运算证实下我们的结论 123456789101112-4 + (-7):4：00000000 00000000 00000000 00000100，7：00000000 00000000 00000000 00000111(-4补码)：11111111 11111111 11111111 11111100， (-7补码)：11111111 11111111 11111111 1111100111：00000000 00000000 00000000 00001011(-11补码)：11111111 11111111 11111111 11110101 11111111 11111111 11111111 11111100+ 11111111 11111111 11111111 11111001-----------------------------------------&#x3D; 11111111 11111111 11111111 11110101 所以我们的结论是可行的，补码和原码互为互补关系。&emsp;&emsp;再次声明一下，所有的这些对于正数来说都是不需要的，正数的原码，反码，补码都是一样的。&emsp;&emsp;那么反码是什么呢？反码比较好理解，就是对原码取反（符号为不变，其他值取反），如 12345678-1010000000 00000000 00000000 00001010~(-10)11111111 11111111 11111111 11110101-1110000000 00000000 00000000 00010101~(-11)10000000 00000000 00000000 00001010 这边我们可以发现个规律：补码 = 反码 + 1，你不信可以试试。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"原理","slug":"原理","permalink":"http://yoursite.com/tags/%E5%8E%9F%E7%90%86/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-12-28T12:22:45.895Z","updated":"2020-01-05T11:52:48.926Z","comments":true,"path":"2019/12/28/hello-world/","link":"","permalink":"http://yoursite.com/2019/12/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"建站","slug":"建站","permalink":"http://yoursite.com/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[]}]}